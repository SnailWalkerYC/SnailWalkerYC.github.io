---
layout: post
title: 动态规划的理解
date: 2019-06-01
categories: [technology]
tags: [tech]
comments: false
---

#### 定义

动态规划，一般用于优化问题，解决类似于xx存不存在，有没有，有多少这样的问题。问到具体的方法的时候，需要在动态规划中加些信息来恢复出最佳方案。动态规划的核心思想就是子问题的最优解也是问题的最优解的一部分，同时在求解问题答案的时候，需要多次重复调用子问题，就可以使用记忆化搜索来减少计算，使得计算复杂度下降通常可以达到一个数量级及以上。动态规划求解是要求具有最优子结构的，既是一个问题的最优解可以从子问题的最优解中获取。



动态规划的步骤一般是：

- 构造最优解的结构
- 递归定义最优解
- 将最优解从自顶向下改为自底向上
- 根据已有的信息构造出最优解



#### 单个序列

- Rod cutting: 原始的不用记忆化的时候时间复杂度T(n) = $2^n$，使用归纳法（inductive method）或者根据切割的次数$2^{(n-1)}$ 来计算。

最原始的求解自顶向下的C++实现：这里面的核心是要理解为什么$r_n = max (p_i + r_{n-i})$

```c++
int MaxRodCuttingPrice(const vector<int>& price, const int n) {
  if (n <= 0) return 0;
  int max_price = 0;
  for (int i = 1; i <= n; ++i) {
    max_price = max(max_price, MaxRodCuttingPrice(price, n - 1));
  }
  return max_price;
}
```

加入记忆化搜索之后的，自顶向下：这个时间复杂度使用aggregate analysis比较合适。

```c++
int MaxRodCuttingPrice(const vector<int>& price, const int n, vector<int>* max_prices) {
  if (n <= 0) return 0;
  if (*max_prices[n] >= 0) return *max_prices[n];
  
  int max_price = 0;
  for (int i = 1; i <= n; ++i) {
    max_price = max(max_price, price[i] + MaxRodCuttingPrice(price, n - i, max_prices);
  }
  *max_prices[n] = max_price;
  
  return max_price;
}
```

自底向上的实现：计算复杂度和上面的一样都是$\Theta (n^2)$.

```c++
int MaxRodCuttingPrice(vector<int>& price, int n) {
  if (n <= 0) return 0;
  vector<int> max_prices(MIN_INT, price.size());
  max_prices[0] = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= i; ++j) {
      max_prices[i] = max(max_prices[i], price[j] + max_prices[i - j]);
    }
  }
  return max_prices[n];
}
```

如果这个题目需要给出最佳的一个切法的话，可以增加一些辅助信息：

```c++
vector<int> FindMaxRodCuttingPrice(const vector<int>& price, 
                                   const int n, vector<int>* selection) {
  if (n <= 0) return {};
  
  vector<int> max_prices(n + 1, 0);
  for (int i = 1; i <= n; ++i) {
    int max_price = 0;
    for (int j = 1; j <= i; ++j) {
      if (max_price < max_prices[i - j] + price[j]) {
        max_price = max_prices[i - j] + price[j];
        *selection[i] = j;
      }
    }
    max_prices[i] = max_price;
  }
  return FindBestSolution(selection, n);
}

vector<int> FindBestSolution(const vector<int>& selection, const int n) {
  if (n <= 0) return {};
  vector<int> remain_solution = FindBestSolution(selection, n - selection[n]);
  remain_solution.push_back(selection[n]);
  return remain_solution;
}
```

变形，如果每次cut是需要付出额外的费用，那么怎么计算最大收益：

```c++
int MaxRodCuttingPrice(const vector<int>& price, const int n, const int c) {
  if (n <= 0) return 0;
  vector<int> max_prices(n+1, 0);
  for (int i = 1; i <= n; ++i) {
    int max_price = 0;
    for (int j = 1; j <= i; ++j) {
      const int cur_price = max_prices[i - j] + price[j] - (i == j ? 0:c);
      max_price = max(cur_price, max_price);
    }
    max_prices[i] = max_price;
  }
  return max_price[n];
}
```

修改递归版本的使得能够返回best solution: 

```c++
int FindMaxRodCuttingPrice(const vector<int>& price, const int n, 
                            vector<int>* selection, vector<int>* max_prices) {
  if (n <= 0) return;
  if (*max_prices[n] >= 0) return *max_prices[n];
  
  int max_price = 0;
  for (int i = 1; i <= n; ++i) {
    if (max_price < price[i] + FindMaxRodCuttingPrice(n - i, selection, max_prices)) {
      *selection[n] = i;
      max_price = price[i] + FindMaxRodCuttingPrice(n - i, selection, max_prices);
    }
  }
  *max_prices[n] = max_price;
  return max_price;
}

vector<int> FindBestSolution(selection, n); // From the above function.
```

- Matrix chain multiplication: 加括号的次数 $P(n) = \sum_{k=1}^{n-1} P(k)P(n-k) = 2^n$ 是属于卡塔兰数。通过简单的DP即可变为：$O(n^3)$. 状态转移为：$m[i,j] = min \{m[i,k] + m[k+1,j] + p_{i-1} p_k p_j\}$ 

```c++
int FindMinMatrixChainMultiplication(const vector<int>& matrix_dims, 
                                     vector<int>* split_position) {
  const auto& dims_size = matrix_dims.size() + 1;
  vector<vector<int>> costs(dims_size, vector<int>(dims_size + 1, INT_MAX));
  for (int len = 2; len <= dims_size; ++len) {
    for (int i = 1; i <= dims_size - len + 1; ++i) {
      for (int j = i; j < i + len; ++j) {
        const int cur_cost = costs[i][j] + costs[j+1][i+len-1]
                                + matrix_dims[i-1]*matrix_dims[j]*matrix_dims[i+len-1];
        if (cur_cost < costs[i][i+len-1]) {
          costs[i][i+len-1] = cur_cost;
          split_position[i][i+len-1] = j;
        }
      }
    }
  }
  return costs[1][dims_size];
}

string FindBestSolution(const vector<vector<int>>& split_position, int i, int j) {
  if (i > j) return "";
  if (i == j) return to_string(i);
  string left = FindBestSolution(split_position, i, split_position[i][j]);
  string right = FindBestSolution(split_position, split_position[i][j] + 1, j);
  return "(" + left + right + ")";
}
```

改成递归版本：

```c++
int FindMinMatrixChainMultiplication(const vector<int>& matrix_dims,
                                     vector<vector<int>>* costs,
                                     vector<int>* split_position,
                                     int i, int j) {
  if (i >= j) return 0;
  if (costs[i][j] > 0) return costs[i][j];
  
  int min_cost = INT_MAX;
  for (int k = i; k <= j; ++k) {
    const auto cur_cost = matrix_dims[i-1]*matrix_dims[k]*matrix_dims[j] + 
      FindMinMatrixChainMultiplication(matrix_dims, costs, split_position, i, k) +
      FindMinMatrixChainMultiplication(matrix_dims, costs, split_position, k + 1, j); 
    if (cur_cost < min_cost) {
      min_cost = cur_cost;
      split_position[i][j] = k;
    }
  }
  costs[i][j] = min_cost;
  return min_cost;
}
```

#### 两个序列

- longest common subsequence

iterative method:

```c++
int LongestCommonSubsequence(const string& s1, const string& s2) {
  vector<vector<int>> record(s1.size() + 1, vector<int>(s2.size() + 1, 0));
  for (int i = 1; i <= s1.size(); ++i) {
    for (int j = 1; j < s2.size(); ++j) {
      record[i][j] = (s1[i-1] == s2[j-1])?record[i-1][j-1]+1:
           max(record[i-1][j], record[i][j-1]);
    }
  }
  return record[s1.size()][s2.size()];
}
```

给出最优解，使用额外的数组记录：

```c++
int MaxLongestCommonSubsequence(const string& s1, const string& s2, vector<int>* solution) {
  vector<vector<int>> record(s1.size()+1, vector<int>(s2.size()+1, 0));
  vector<vector<int>> trace(s1.size()+1, vector<int>(s2.size()+1, 0));
  for (int i = 1; i <= s1.size(); ++i) {
    for (int j = 1; j <= s2.size(); ++j) {
      if (s1[i-1] == s2[j-1]) {
        record[i][j] = record[i-1][j-1] + 1;
        trace[i][j] = 0;
      } else {
        if (record[i-1][j] > record[i][j-1]) {
          record[i][j] = record[i-1][j];
          trace[i][j] = -1;
        } else {
          record[i][j] = record[i][j-1];
          trace[i][j] = 1;
        }
      }
    }
  }
  
  FindBestSolution(trace, solution);
  
  return record[s1.size()][s2.size()];
}

void FindBestSolution(vector<vector<int>>& trace, vector<int>* solution) {
  int row = trace.size();
  int col = trace[0].size();
  while (row > 0 && col > 0) {
    if (!trace[row][col]) {
      *solution.push_back(row);
      --row;
      --col;
    } else {
      if (trace[row][col] == trace[row-1][col]) --row;
      else --col;
    }
  }
}
```

不使用额外的数组记录：

```C++
int FindLongestCommonSubsequence(const string& s1, const string& s2, vector<int>* solution) {
  vector<vector<int>> record(s1.size()+1, vector<int>(s2.size()+1, 0));
  for (int i = 1; i <= s1.size(); ++i) {
    for (int j = 1; j <= s2.size(); ++j) {
      record[i][j] = (s1[i-1] == s2[j-1]) ? record[i-1][j-1] + 1:
            max(record[i-1][j], record[i][j-1]);
    }
  }
  FindBestSolution(trace, solution);
}

void FindBestSolution(const vector<vector<int>>& trace, const string& s1, 
                      const string& s2,
                      vector<int>* solution) {
  int row = trace.size();
  int col = trace[0].size();
  while (row > 0 && col > 0) {
    if (trace[row][col] == trace[row-1][col-1] + 1 && s1[row] == s2[col]) {
      *solution.push_back(row);
      --row;
      --col;
    } else {
      if (trace[row][col] == trace[row-1][col]) --row;
      else --col;
    }
  }
}
```

很多时候是有多个相同长度的解的，找出所有的解：或者是有多少组最优解

```c++
int FindLongestCommonSubsequence(const string& s1, const string& s2, vector<vector<int>>* solutions) {
  vector<vector<int>> record(s1.size()+1, vector<int>(s2.size()+1, 0));
  for (int i = 1; i <= s1.size(); ++i) {
    for (int j = 1; j <= s2.size(); ++j) {
      record[i][j] = (s1[i-1] == s2[j-1]) ? record[i-1][j-1]+1 : 
                 max(record[i-1][j], [i][j-1]);
    }
  }
  FindBestSolution(s1, s2, trace, solutions, {}, s1.size(), s2.size());
  return record[s1.size()][s2.size()];
}

void FindBestSolution(const string& s1, const string& s2, const vector<vector<int>>& trace,
                      vector<vector<int>>* solutions, int row, int col)
```

对于空间进行优化：（O(mn) -> (2n) -> (n + 1)）空间优化对给出长度是可以的，但是需要给出具体的solution需要改进。

```c++
int FindLongestCommonSubsequence(const string& s1, const string& s2) {
  vector<int> record(s2.size()+1, 0);
  int lcs_pre = 0;
  for (int i = 1; i <= s1.size(); ++i) {
    for (int j = 1; j <= s2.size(); ++j) {
      int tmp = record[j];
      record[j] = s1[i-1] == s2[j-1] ? lcs_pre + 1 : 
            max(record[j], record[j-1]);
      lcs_pre = tmp;
    }
  }
  return record[s2.size()];
}
```

- longest monotonically increasing subsequence: 这道问题可以先将vector排序再求LCS。

```c++
int FindLongestMonotonicallyIncreasingSubseuqnce(const vector<int>& nums, vector<int>* solution) {
  vector<int> record(nums.size()+1, 0);
  vector<int> trace(nums.size()+1, 0);
  for (int i = 1; i <= nums.size(); ++i) {
    for (int j = 1; j < i; ++j) {
      const auto flag = nums[j-1] >= nums[i-1];
      if (record[i] <= record[j]+flag) {
        record[i] = record[j] + flag;
        trace[i] = j;
      }
    }
  }
  FindBestSolution(nums, trace, record, solution);
  return *max_element(record.begin(), record.end());
}

void FindBestSolution(const vector<int>& nums, const vector<int>& trace, const vector<int>& record,
                      vector<int>* solution) {
  int idx = GetMaxLMIS(record);
  while (!idx) {
    *solution.push_back(nums[idx-1]);
    idx = trace[idx];
  }
}
  
```



#### 动态规划的元素

什么时候可以使用动规？在有**最优子结构(optimal substructrue)**和**重叠子问题(overlapping subproblems)**的时候。最优子结构就是解决优化问题的时候使用的子问题的解，也是该子问题的最优解。问题的最优解可以通过组合子问题的最优解得到，这里用到了一个思想“cut and paste”。动规的整个思想更加贴近于归纳推理(inductive reasoning)。



动规的运行时间依赖于子问题的数量以及每个子问题的选择。有些问题里面不存在最优子结构，比如有向最长路径，需要子问题之间没有依赖性。重叠子问题，求解问题中需要使用大量重叠子问题的解，使用动态规划记忆化搜索就更有价值。



merge sort 无法使用dp的原因是因为它没有最优子结构，子问题之间没有overlap。