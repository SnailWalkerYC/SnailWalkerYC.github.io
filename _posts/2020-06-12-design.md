---
layout: post
title: design
date: 2020-06-12
categories: [technology]
tags: [tech]
comments: false

---



### Design

```c++
// LRU Cache
class LRUCache {
 public:
  unordered_map<int,pair<int, list<int>::iterator>> _rec;
  int _capacity;
  list<int> _keyset;
    
  LRUCache(int capacity) {
    _capacity = capacity;
  }
    
  int get(int key) {
    if (_rec.find(key) != _rec.end()) {
      _keyset.erase(_rec[key].second);
      _keyset.push_front(key);
      _rec[key] = make_pair(_rec[key].first, _keyset.begin());
      return _rec[key].first; 
    }
    return -1;
  }
    
  void put(int key, int value) {
    if (_keyset.size() >= _capacity && _rec.find(key) == _rec.end()) {
      int rm_key = _keyset.back();
      _keyset.pop_back();
      _rec.erase(rm_key);
    }
    if (_rec.find(key) != _rec.end()) {
      _keyset.erase(_rec[key].second);
    }
    _keyset.push_front(key);
    _rec[key] = make_pair(value, _keyset.begin());
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */

// LFU Cache
// unordered_map, visit times->list of data; 
// unordered_map, key->pair(count, key iterator, val)
class LFUCache {
 public:
  class VALUE{
   public:
    int _value;
    int _cnt;
    list<int>::iterator _listItr;
    VALUE(int v, int c, list<int>::iterator list_itr) {
      _value = v;
      _cnt = c;
      _listItr = list_itr;
    }
  };
    
  int _capacity;
  int _minCnt;
  unordered_map<int, VALUE*> _recKey;
  unordered_map<int, list<int>> _hirarchCache;
    
  LFUCache(int capacity) {
    _capacity = capacity;
    _minCnt = 0;
  }
    
  int get(int key) {
    if (_recKey.find(key) == _recKey.end() || _capacity <= 0) {
      return -1;
    }
        
    auto cur_node = _recKey[key];
    _hirarchCache[cur_node->_cnt].erase(cur_node->_listItr);
    if (_minCnt == cur_node->_cnt && !_hirarchCache[cur_node->_cnt].size()) {
      ++_minCnt;
    }
    cur_node->_cnt++;
    _hirarchCache[cur_node->_cnt].push_front(key);
    _recKey[key] = new VALUE(cur_node->_value, cur_node->_cnt, _hirarchCache[cur_node->_cnt].begin());
        
    return cur_node->_value;
  }
    
  void put(int key, int value) {
    if (_capacity <= 0) {
      return;
    }
    if (_recKey.find(key) == _recKey.end() && _recKey.size() < _capacity) {
      _hirarchCache[1].push_front(key);
      VALUE* new_value = new VALUE(
          value,
          1,
          _hirarchCache[1].begin()
      );
      _recKey.insert(make_pair(key, new_value));
      _minCnt = 1;
      return;
    }
        
    if (_recKey.find(key) != _recKey.end()) {
      auto cur_node = _recKey[key];
      _hirarchCache[cur_node->_cnt].erase(cur_node->_listItr);
      if (_minCnt == cur_node->_cnt && !_hirarchCache[cur_node->_cnt].size()) {
        ++_minCnt;
      }
      cur_node->_cnt++;
      _hirarchCache[cur_node->_cnt].push_front(key);
      _recKey[key] = new VALUE(
                value, 
                cur_node->_cnt,                       
                _hirarchCache[cur_node->_cnt].begin());
      return;
    }
        
    auto cur_layer = _hirarchCache[_minCnt];
    int rm_key = cur_layer.back();
        
    _hirarchCache[_minCnt].pop_back();
    _recKey.erase(rm_key);
    _minCnt = 1;
    _hirarchCache[1].push_front(key);
    _recKey[key] = new VALUE(
               value,
               1,
               _hirarchCache[1].begin());
  }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */

// Min Stack
// Two stack, one is normal, the other is the min stack.
class MinStack {
 public:
  stack<int> stk1;
  stack<int> stk2;
  /** initialize your data structure here. */
  MinStack() {}
    
  void push(int x) {
    stk1.push(x);
    if(stk2.empty() || x<=getMin())
        stk2.push(x);
  }
    
  void pop() {
    if(stk1.top()==stk2.top())
        stk2.pop();
    stk1.pop();
  }
    
  int top() {
    return stk1.size()?stk1.top():INT_MAX;
  }
    
  int getMin() {
    return stk2.size()?stk2.top():INT_MAX;
  }
};

// 170. Two Sum III - Data structure design. Hash table; or tow sum with status(sorted) or not.

// 173. Binary Search Tree Iterator
// 1. Inorder go through with store in a vector, then later is easier.
// 2. With iteration version of the in-order
class BSTIterator {
 public:
  stack<TreeNode*> record;
  BSTIterator(TreeNode* root) {
    while (root != nullptr)  {
      record.push(root);
      root = root->left;
    }      
  }
    
  /** @return the next smallest number */
  int next() {
    const auto tpr = record.top();
    const int tpr_val = tpr->val;
    record.pop();
    auto tpr_right = tpr->right;
    while (tpr_right != nullptr) {
      record.push(tpr_right);
      tpr_right = tpr_right->left;
    }
    return tpr_val;
  }
    
  /** @return whether we have a next smallest number */
  bool hasNext() {
    return record.size() > 0;    
  }
};

// To 225.
```

